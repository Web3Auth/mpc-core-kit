var Ce=n=>{throw TypeError(n)};var de=(n,t,e)=>t.has(n)||Ce("Cannot "+e);var O=(n,t,e)=>(de(n,t,"read from private field"),e?e.call(n):t.get(n)),$=(n,t,e)=>t.has(n)?Ce("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(n):t.set(n,e),I=(n,t,e,r)=>(de(n,t,"write to private field"),r?r.call(n,e):t.set(n,e),e),ne=(n,t,e)=>(de(n,t,"access private method"),e);import{g as ot,a as L,b as rt,h as _,H as Xe,c as wn,t as Je,e as se,d as Bn,f as ge,o as En,w as Qe,r as nt,u as S,i as An,j as vn,k as be,l as Wt,S as St,m as ke,n as Xt,p as oe,q as ae,s as we,v as tn,x as st,y as Pn,z as ie,A as tt}from"./index-B-NJ4RXq.js";import{M as kr,T as _r,Z as qr,F as Rr,E as $r,I as zr,D as Vr,C as Kr,G as Zr,L as jr,J as Dr,K as Mr,N as Yr,B as Wr}from"./index-B-NJ4RXq.js";function In(n){let t=n.toString(16);for(;t.length<2;)t="0"+t;return"0x"+t}function _e(n,t,e){let r=0;for(let s=0;s<e;s++)r=r*256+n[t+s];return r}function qe(n,t,e,r){const s=[];for(;e<t+1+r;){const i=en(n,e);s.push(i.result),e+=i.consumed,rt(e<=t+1+r,"child data too short","BUFFER_OVERRUN",{buffer:n,length:r,offset:t})}return{consumed:1+r,result:s}}function en(n,t){rt(n.length!==0,"data too short","BUFFER_OVERRUN",{buffer:n,length:0,offset:1});const e=r=>{rt(r<=n.length,"data short segment too short","BUFFER_OVERRUN",{buffer:n,length:n.length,offset:r})};if(n[t]>=248){const r=n[t]-247;e(t+1+r);const s=_e(n,t+1,r);return e(t+1+r+s),qe(n,t,t+1+r,r+s)}else if(n[t]>=192){const r=n[t]-192;return e(t+1+r),qe(n,t,t+1,r)}else if(n[t]>=184){const r=n[t]-183;e(t+1+r);const s=_e(n,t+1,r);e(t+1+r+s);const i=_(n.slice(t+1+r,t+1+r+s));return{consumed:1+r+s,result:i}}else if(n[t]>=128){const r=n[t]-128;e(t+1+r);const s=_(n.slice(t+1,t+1+r));return{consumed:1+r,result:s}}return{consumed:1,result:In(n[t])}}function ce(n){const t=ot(n,"data"),e=en(t,0);return L(e.consumed===t.length,"unexpected junk after rlp payload","data",n),e.result}function Re(n){const t=[];for(;n;)t.unshift(n&255),n>>=8;return t}function nn(n){if(Array.isArray(n)){let r=[];if(n.forEach(function(i){r=r.concat(nn(i))}),r.length<=55)return r.unshift(192+r.length),r;const s=Re(r.length);return s.unshift(247+s.length),s.concat(r)}const t=Array.prototype.slice.call(ot(n,"object"));if(t.length===1&&t[0]<=127)return t;if(t.length<=55)return t.unshift(128+t.length),t;const e=Re(t.length);return e.unshift(183+e.length),e.concat(t)}const $e="0123456789abcdef";function Kt(n){let t="0x";for(const e of nn(n))t+=$e[e>>4],t+=$e[e&15];return t}class rn extends Xe{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,wn(t);const r=Je(e);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,i=new Uint8Array(s);i.set(r.length>s?t.create().update(r).digest():r);for(let c=0;c<i.length;c++)i[c]^=54;this.iHash.update(i),this.oHash=t.create();for(let c=0;c<i.length;c++)i[c]^=106;this.oHash.update(i),i.fill(0)}update(t){return se(this),this.iHash.update(t),this}digestInto(t){se(this),Bn(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:s,destroyed:i,blockLen:c,outputLen:a}=this;return t=t,t.finished=s,t.destroyed=i,t.blockLen=c,t.outputLen=a,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const sn=(n,t,e)=>new rn(n,t).update(e).digest();sn.create=(n,t)=>new rn(n,t);function Sn(n,t,e,r){if(typeof n.setBigUint64=="function")return n.setBigUint64(t,e,r);const s=BigInt(32),i=BigInt(4294967295),c=Number(e>>s&i),a=Number(e&i),o=r?4:0,l=r?0:4;n.setUint32(t+o,c,r),n.setUint32(t+l,a,r)}class on extends Xe{constructor(t,e,r,s){super(),this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=ge(this.buffer)}update(t){se(this);const{view:e,buffer:r,blockLen:s}=this;t=Je(t);const i=t.length;for(let c=0;c<i;){const a=Math.min(s-this.pos,i-c);if(a===s){const o=ge(t);for(;s<=i-c;c+=s)this.process(o,c);continue}r.set(t.subarray(c,c+a),this.pos),this.pos+=a,c+=a,this.pos===s&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){se(this),En(t,this),this.finished=!0;const{buffer:e,view:r,blockLen:s,isLE:i}=this;let{pos:c}=this;e[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>s-c&&(this.process(r,0),c=0);for(let f=c;f<s;f++)e[f]=0;Sn(r,s-8,BigInt(this.length*8),i),this.process(r,0);const a=ge(t),o=this.outputLen;if(o%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const l=o/4,y=this.get();if(l>y.length)throw new Error("_sha2: outputLen bigger than state");for(let f=0;f<l;f++)a.setUint32(4*f,y[f],i)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:r,length:s,finished:i,destroyed:c,pos:a}=this;return t.length=s,t.pos=a,t.finished=i,t.destroyed=c,s%e&&t.buffer.set(r),t}}const Ln=(n,t,e)=>n&t^~n&e,Hn=(n,t,e)=>n&t^n&e^t&e,Nn=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),gt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),bt=new Uint32Array(64);class Fn extends on{constructor(){super(64,32,8,!1),this.A=gt[0]|0,this.B=gt[1]|0,this.C=gt[2]|0,this.D=gt[3]|0,this.E=gt[4]|0,this.F=gt[5]|0,this.G=gt[6]|0,this.H=gt[7]|0}get(){const{A:t,B:e,C:r,D:s,E:i,F:c,G:a,H:o}=this;return[t,e,r,s,i,c,a,o]}set(t,e,r,s,i,c,a,o){this.A=t|0,this.B=e|0,this.C=r|0,this.D=s|0,this.E=i|0,this.F=c|0,this.G=a|0,this.H=o|0}process(t,e){for(let f=0;f<16;f++,e+=4)bt[f]=t.getUint32(e,!1);for(let f=16;f<64;f++){const w=bt[f-15],P=bt[f-2],m=nt(w,7)^nt(w,18)^w>>>3,u=nt(P,17)^nt(P,19)^P>>>10;bt[f]=u+bt[f-7]+m+bt[f-16]|0}let{A:r,B:s,C:i,D:c,E:a,F:o,G:l,H:y}=this;for(let f=0;f<64;f++){const w=nt(a,6)^nt(a,11)^nt(a,25),P=y+w+Ln(a,o,l)+Nn[f]+bt[f]|0,u=(nt(r,2)^nt(r,13)^nt(r,22))+Hn(r,s,i)|0;y=l,l=o,o=a,a=c+P|0,c=i,i=s,s=r,r=P+u|0}r=r+this.A|0,s=s+this.B|0,i=i+this.C|0,c=c+this.D|0,a=a+this.E|0,o=o+this.F|0,l=l+this.G|0,y=y+this.H|0,this.set(r,s,i,c,a,o,l,y)}roundClean(){bt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const an=Qe(()=>new Fn),[Gn,On]=S.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(n=>BigInt(n))),yt=new Uint32Array(80),pt=new Uint32Array(80);class Un extends on{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:t,Al:e,Bh:r,Bl:s,Ch:i,Cl:c,Dh:a,Dl:o,Eh:l,El:y,Fh:f,Fl:w,Gh:P,Gl:m,Hh:u,Hl:d}=this;return[t,e,r,s,i,c,a,o,l,y,f,w,P,m,u,d]}set(t,e,r,s,i,c,a,o,l,y,f,w,P,m,u,d){this.Ah=t|0,this.Al=e|0,this.Bh=r|0,this.Bl=s|0,this.Ch=i|0,this.Cl=c|0,this.Dh=a|0,this.Dl=o|0,this.Eh=l|0,this.El=y|0,this.Fh=f|0,this.Fl=w|0,this.Gh=P|0,this.Gl=m|0,this.Hh=u|0,this.Hl=d|0}process(t,e){for(let b=0;b<16;b++,e+=4)yt[b]=t.getUint32(e),pt[b]=t.getUint32(e+=4);for(let b=16;b<80;b++){const H=yt[b-15]|0,v=pt[b-15]|0,x=S.rotrSH(H,v,1)^S.rotrSH(H,v,8)^S.shrSH(H,v,7),A=S.rotrSL(H,v,1)^S.rotrSL(H,v,8)^S.shrSL(H,v,7),E=yt[b-2]|0,k=pt[b-2]|0,G=S.rotrSH(E,k,19)^S.rotrBH(E,k,61)^S.shrSH(E,k,6),F=S.rotrSL(E,k,19)^S.rotrBL(E,k,61)^S.shrSL(E,k,6),z=S.add4L(A,F,pt[b-7],pt[b-16]),j=S.add4H(z,x,G,yt[b-7],yt[b-16]);yt[b]=j|0,pt[b]=z|0}let{Ah:r,Al:s,Bh:i,Bl:c,Ch:a,Cl:o,Dh:l,Dl:y,Eh:f,El:w,Fh:P,Fl:m,Gh:u,Gl:d,Hh:g,Hl:B}=this;for(let b=0;b<80;b++){const H=S.rotrSH(f,w,14)^S.rotrSH(f,w,18)^S.rotrBH(f,w,41),v=S.rotrSL(f,w,14)^S.rotrSL(f,w,18)^S.rotrBL(f,w,41),x=f&P^~f&u,A=w&m^~w&d,E=S.add5L(B,v,A,On[b],pt[b]),k=S.add5H(E,g,H,x,Gn[b],yt[b]),G=E|0,F=S.rotrSH(r,s,28)^S.rotrBH(r,s,34)^S.rotrBH(r,s,39),z=S.rotrSL(r,s,28)^S.rotrBL(r,s,34)^S.rotrBL(r,s,39),j=r&i^r&a^i&a,et=s&c^s&o^c&o;g=u|0,B=d|0,u=P|0,d=m|0,P=f|0,m=w|0,{h:f,l:w}=S.add(l|0,y|0,k|0,G|0),l=a|0,y=o|0,a=i|0,o=c|0,i=r|0,c=s|0;const h=S.add3L(G,z,et);r=S.add3H(h,k,F,j),s=h|0}({h:r,l:s}=S.add(this.Ah|0,this.Al|0,r|0,s|0)),{h:i,l:c}=S.add(this.Bh|0,this.Bl|0,i|0,c|0),{h:a,l:o}=S.add(this.Ch|0,this.Cl|0,a|0,o|0),{h:l,l:y}=S.add(this.Dh|0,this.Dl|0,l|0,y|0),{h:f,l:w}=S.add(this.Eh|0,this.El|0,f|0,w|0),{h:P,l:m}=S.add(this.Fh|0,this.Fl|0,P|0,m|0),{h:u,l:d}=S.add(this.Gh|0,this.Gl|0,u|0,d|0),{h:g,l:B}=S.add(this.Hh|0,this.Hl|0,g|0,B|0),this.set(r,s,i,c,a,o,l,y,f,w,P,m,u,d,g,B)}roundClean(){yt.fill(0),pt.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const Tn=Qe(()=>new Un);function Cn(){if(typeof self<"u")return self;if(typeof window<"u")return window;if(typeof globalThis<"u")return globalThis;throw new Error("unable to locate global object")}const ze=Cn();ze.crypto||ze.msCrypto;function kn(n){switch(n){case"sha256":return an.create();case"sha512":return Tn.create()}L(!1,"invalid hashing algorithm name","algorithm",n)}const cn=function(n){return kn("sha256").update(n).digest()};let ln=cn,fn=!1;function Mt(n){const t=ot(n,"data");return _(ln(t))}Mt._=cn;Mt.lock=function(){fn=!0};Mt.register=function(n){if(fn)throw new Error("sha256 is locked");ln=n};Object.freeze(Mt);Object.freeze(Mt);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const un=BigInt(0),le=BigInt(1),_n=BigInt(2),fe=n=>n instanceof Uint8Array,qn=Array.from({length:256},(n,t)=>t.toString(16).padStart(2,"0"));function Zt(n){if(!fe(n))throw new Error("Uint8Array expected");let t="";for(let e=0;e<n.length;e++)t+=qn[n[e]];return t}function hn(n){const t=n.toString(16);return t.length&1?`0${t}`:t}function Pe(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return BigInt(n===""?"0":`0x${n}`)}function jt(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);const t=n.length;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const e=new Uint8Array(t/2);for(let r=0;r<e.length;r++){const s=r*2,i=n.slice(s,s+2),c=Number.parseInt(i,16);if(Number.isNaN(c)||c<0)throw new Error("Invalid byte sequence");e[r]=c}return e}function It(n){return Pe(Zt(n))}function Ie(n){if(!fe(n))throw new Error("Uint8Array expected");return Pe(Zt(Uint8Array.from(n).reverse()))}function Dt(n,t){return jt(n.toString(16).padStart(t*2,"0"))}function Se(n,t){return Dt(n,t).reverse()}function Rn(n){return jt(hn(n))}function Q(n,t,e){let r;if(typeof t=="string")try{r=jt(t)}catch(i){throw new Error(`${n} must be valid hex string, got "${t}". Cause: ${i}`)}else if(fe(t))r=Uint8Array.from(t);else throw new Error(`${n} must be hex string or Uint8Array`);const s=r.length;if(typeof e=="number"&&s!==e)throw new Error(`${n} expected ${e} bytes, got ${s}`);return r}function Jt(...n){const t=new Uint8Array(n.reduce((r,s)=>r+s.length,0));let e=0;return n.forEach(r=>{if(!fe(r))throw new Error("Uint8Array expected");t.set(r,e),e+=r.length}),t}function $n(n,t){if(n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==t[e])return!1;return!0}function zn(n){if(typeof n!="string")throw new Error(`utf8ToBytes expected string, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}function Vn(n){let t;for(t=0;n>un;n>>=le,t+=1);return t}function Kn(n,t){return n>>BigInt(t)&le}const Zn=(n,t,e)=>n|(e?le:un)<<BigInt(t),Le=n=>(_n<<BigInt(n-1))-le,ye=n=>new Uint8Array(n),Ve=n=>Uint8Array.from(n);function dn(n,t,e){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=ye(n),s=ye(n),i=0;const c=()=>{r.fill(1),s.fill(0),i=0},a=(...f)=>e(s,r,...f),o=(f=ye())=>{s=a(Ve([0]),f),r=a(),f.length!==0&&(s=a(Ve([1]),f),r=a())},l=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let f=0;const w=[];for(;f<t;){r=a();const P=r.slice();w.push(P),f+=r.length}return Jt(...w)};return(f,w)=>{c(),o(f);let P;for(;!(P=w(l()));)o();return c(),P}}const jn={bigint:n=>typeof n=="bigint",function:n=>typeof n=="function",boolean:n=>typeof n=="boolean",string:n=>typeof n=="string",stringOrUint8Array:n=>typeof n=="string"||n instanceof Uint8Array,isSafeInteger:n=>Number.isSafeInteger(n),array:n=>Array.isArray(n),field:(n,t)=>t.Fp.isValid(n),hash:n=>typeof n=="function"&&Number.isSafeInteger(n.outputLen)};function te(n,t,e={}){const r=(s,i,c)=>{const a=jn[i];if(typeof a!="function")throw new Error(`Invalid validator "${i}", expected function`);const o=n[s];if(!(c&&o===void 0)&&!a(o,n))throw new Error(`Invalid param ${String(s)}=${o} (${typeof o}), expected ${i}`)};for(const[s,i]of Object.entries(t))r(s,i,!1);for(const[s,i]of Object.entries(e))r(s,i,!0);return n}const Dn=Object.freeze(Object.defineProperty({__proto__:null,bitGet:Kn,bitLen:Vn,bitMask:Le,bitSet:Zn,bytesToHex:Zt,bytesToNumberBE:It,bytesToNumberLE:Ie,concatBytes:Jt,createHmacDrbg:dn,ensureBytes:Q,equalBytes:$n,hexToBytes:jt,hexToNumber:Pe,numberToBytesBE:Dt,numberToBytesLE:Se,numberToHexUnpadded:hn,numberToVarBytesBE:Rn,utf8ToBytes:zn,validateObject:te},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Z=BigInt(0),q=BigInt(1),Et=BigInt(2),Mn=BigInt(3),Be=BigInt(4),Ke=BigInt(5),Ze=BigInt(8);BigInt(9);BigInt(16);function D(n,t){const e=n%t;return e>=Z?e:t+e}function Yn(n,t,e){if(e<=Z||t<Z)throw new Error("Expected power/modulo > 0");if(e===q)return Z;let r=q;for(;t>Z;)t&q&&(r=r*n%e),n=n*n%e,t>>=q;return r}function W(n,t,e){let r=n;for(;t-- >Z;)r*=r,r%=e;return r}function Ee(n,t){if(n===Z||t<=Z)throw new Error(`invert: expected positive integers, got n=${n} mod=${t}`);let e=D(n,t),r=t,s=Z,i=q;for(;e!==Z;){const a=r/e,o=r%e,l=s-i*a;r=e,e=o,s=i,i=l}if(r!==q)throw new Error("invert: does not exist");return D(s,t)}function Wn(n){const t=(n-q)/Et;let e,r,s;for(e=n-q,r=0;e%Et===Z;e/=Et,r++);for(s=Et;s<n&&Yn(s,t,n)!==n-q;s++);if(r===1){const c=(n+q)/Be;return function(o,l){const y=o.pow(l,c);if(!o.eql(o.sqr(y),l))throw new Error("Cannot find square root");return y}}const i=(e+q)/Et;return function(a,o){if(a.pow(o,t)===a.neg(a.ONE))throw new Error("Cannot find square root");let l=r,y=a.pow(a.mul(a.ONE,s),e),f=a.pow(o,i),w=a.pow(o,e);for(;!a.eql(w,a.ONE);){if(a.eql(w,a.ZERO))return a.ZERO;let P=1;for(let u=a.sqr(w);P<l&&!a.eql(u,a.ONE);P++)u=a.sqr(u);const m=a.pow(y,q<<BigInt(l-P-1));y=a.sqr(m),f=a.mul(f,m),w=a.mul(w,y),l=P}return f}}function Xn(n){if(n%Be===Mn){const t=(n+q)/Be;return function(r,s){const i=r.pow(s,t);if(!r.eql(r.sqr(i),s))throw new Error("Cannot find square root");return i}}if(n%Ze===Ke){const t=(n-Ke)/Ze;return function(r,s){const i=r.mul(s,Et),c=r.pow(i,t),a=r.mul(s,c),o=r.mul(r.mul(a,Et),c),l=r.mul(a,r.sub(o,r.ONE));if(!r.eql(r.sqr(l),s))throw new Error("Cannot find square root");return l}}return Wn(n)}const Jn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Qn(n){const t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=Jn.reduce((r,s)=>(r[s]="function",r),t);return te(n,e)}function tr(n,t,e){if(e<Z)throw new Error("Expected power > 0");if(e===Z)return n.ONE;if(e===q)return t;let r=n.ONE,s=t;for(;e>Z;)e&q&&(r=n.mul(r,s)),s=n.sqr(s),e>>=q;return r}function er(n,t){const e=new Array(t.length),r=t.reduce((i,c,a)=>n.is0(c)?i:(e[a]=i,n.mul(i,c)),n.ONE),s=n.inv(r);return t.reduceRight((i,c,a)=>n.is0(c)?i:(e[a]=n.mul(i,e[a]),n.mul(i,c)),s),e}function gn(n,t){const e=t!==void 0?t:n.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function nr(n,t,e=!1,r={}){if(n<=Z)throw new Error(`Expected Field ORDER > 0, got ${n}`);const{nBitLength:s,nByteLength:i}=gn(n,t);if(i>2048)throw new Error("Field lengths over 2048 bytes are not supported");const c=Xn(n),a=Object.freeze({ORDER:n,BITS:s,BYTES:i,MASK:Le(s),ZERO:Z,ONE:q,create:o=>D(o,n),isValid:o=>{if(typeof o!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof o}`);return Z<=o&&o<n},is0:o=>o===Z,isOdd:o=>(o&q)===q,neg:o=>D(-o,n),eql:(o,l)=>o===l,sqr:o=>D(o*o,n),add:(o,l)=>D(o+l,n),sub:(o,l)=>D(o-l,n),mul:(o,l)=>D(o*l,n),pow:(o,l)=>tr(a,o,l),div:(o,l)=>D(o*Ee(l,n),n),sqrN:o=>o*o,addN:(o,l)=>o+l,subN:(o,l)=>o-l,mulN:(o,l)=>o*l,inv:o=>Ee(o,n),sqrt:r.sqrt||(o=>c(a,o)),invertBatch:o=>er(a,o),cmov:(o,l,y)=>y?l:o,toBytes:o=>e?Se(o,i):Dt(o,i),fromBytes:o=>{if(o.length!==i)throw new Error(`Fp.fromBytes: expected ${i}, got ${o.length}`);return e?Ie(o):It(o)}});return Object.freeze(a)}function bn(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const t=n.toString(2).length;return Math.ceil(t/8)}function yn(n){const t=bn(n);return t+Math.ceil(t/2)}function rr(n,t,e=!1){const r=n.length,s=bn(t),i=yn(t);if(r<16||r<i||r>1024)throw new Error(`expected ${i}-1024 bytes of input, got ${r}`);const c=e?It(n):Ie(n),a=D(c,t-q)+q;return e?Se(a,s):Dt(a,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const sr=BigInt(0),pe=BigInt(1);function ir(n,t){const e=(s,i)=>{const c=i.negate();return s?c:i},r=s=>{const i=Math.ceil(t/s)+1,c=2**(s-1);return{windows:i,windowSize:c}};return{constTimeNegate:e,unsafeLadder(s,i){let c=n.ZERO,a=s;for(;i>sr;)i&pe&&(c=c.add(a)),a=a.double(),i>>=pe;return c},precomputeWindow(s,i){const{windows:c,windowSize:a}=r(i),o=[];let l=s,y=l;for(let f=0;f<c;f++){y=l,o.push(y);for(let w=1;w<a;w++)y=y.add(l),o.push(y);l=y.double()}return o},wNAF(s,i,c){const{windows:a,windowSize:o}=r(s);let l=n.ZERO,y=n.BASE;const f=BigInt(2**s-1),w=2**s,P=BigInt(s);for(let m=0;m<a;m++){const u=m*o;let d=Number(c&f);c>>=P,d>o&&(d-=w,c+=pe);const g=u,B=u+Math.abs(d)-1,b=m%2!==0,H=d<0;d===0?y=y.add(e(b,i[g])):l=l.add(e(H,i[B]))}return{p:l,f:y}},wNAFCached(s,i,c,a){const o=s._WINDOW_SIZE||1;let l=i.get(s);return l||(l=this.precomputeWindow(s,o),o!==1&&i.set(s,a(l))),this.wNAF(o,l,c)}}}function pn(n){return Qn(n.Fp),te(n,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...gn(n.n,n.nBitLength),...n,p:n.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function or(n){const t=pn(n);te(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:e,Fp:r,a:s}=t;if(e){if(!r.eql(s,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...t})}const{bytesToNumberBE:ar,hexToBytes:cr}=Dn,vt={Err:class extends Error{constructor(t=""){super(t)}},_parseInt(n){const{Err:t}=vt;if(n.length<2||n[0]!==2)throw new t("Invalid signature integer tag");const e=n[1],r=n.subarray(2,e+2);if(!e||r.length!==e)throw new t("Invalid signature integer: wrong length");if(r[0]&128)throw new t("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new t("Invalid signature integer: unnecessary leading zero");return{d:ar(r),l:n.subarray(e+2)}},toSig(n){const{Err:t}=vt,e=typeof n=="string"?cr(n):n;if(!(e instanceof Uint8Array))throw new Error("ui8a expected");let r=e.length;if(r<2||e[0]!=48)throw new t("Invalid signature tag");if(e[1]!==r-2)throw new t("Invalid signature: incorrect length");const{d:s,l:i}=vt._parseInt(e.subarray(2)),{d:c,l:a}=vt._parseInt(i);if(a.length)throw new t("Invalid signature: left bytes after parsing");return{r:s,s:c}},hexFromSig(n){const t=l=>Number.parseInt(l[0],16)&8?"00"+l:l,e=l=>{const y=l.toString(16);return y.length&1?`0${y}`:y},r=t(e(n.s)),s=t(e(n.r)),i=r.length/2,c=s.length/2,a=e(i),o=e(c);return`30${e(c+i+4)}02${o}${s}02${a}${r}`}},ft=BigInt(0),X=BigInt(1);BigInt(2);const je=BigInt(3);BigInt(4);function lr(n){const t=or(n),{Fp:e}=t,r=t.toBytes||((m,u,d)=>{const g=u.toAffine();return Jt(Uint8Array.from([4]),e.toBytes(g.x),e.toBytes(g.y))}),s=t.fromBytes||(m=>{const u=m.subarray(1),d=e.fromBytes(u.subarray(0,e.BYTES)),g=e.fromBytes(u.subarray(e.BYTES,2*e.BYTES));return{x:d,y:g}});function i(m){const{a:u,b:d}=t,g=e.sqr(m),B=e.mul(g,m);return e.add(e.add(B,e.mul(m,u)),d)}if(!e.eql(e.sqr(t.Gy),i(t.Gx)))throw new Error("bad generator point: equation left != right");function c(m){return typeof m=="bigint"&&ft<m&&m<t.n}function a(m){if(!c(m))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function o(m){const{allowedPrivateKeyLengths:u,nByteLength:d,wrapPrivateKey:g,n:B}=t;if(u&&typeof m!="bigint"){if(m instanceof Uint8Array&&(m=Zt(m)),typeof m!="string"||!u.includes(m.length))throw new Error("Invalid key");m=m.padStart(d*2,"0")}let b;try{b=typeof m=="bigint"?m:It(Q("private key",m,d))}catch{throw new Error(`private key must be ${d} bytes, hex or bigint, not ${typeof m}`)}return g&&(b=D(b,B)),a(b),b}const l=new Map;function y(m){if(!(m instanceof f))throw new Error("ProjectivePoint expected")}class f{constructor(u,d,g){if(this.px=u,this.py=d,this.pz=g,u==null||!e.isValid(u))throw new Error("x required");if(d==null||!e.isValid(d))throw new Error("y required");if(g==null||!e.isValid(g))throw new Error("z required")}static fromAffine(u){const{x:d,y:g}=u||{};if(!u||!e.isValid(d)||!e.isValid(g))throw new Error("invalid affine point");if(u instanceof f)throw new Error("projective point not allowed");const B=b=>e.eql(b,e.ZERO);return B(d)&&B(g)?f.ZERO:new f(d,g,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(u){const d=e.invertBatch(u.map(g=>g.pz));return u.map((g,B)=>g.toAffine(d[B])).map(f.fromAffine)}static fromHex(u){const d=f.fromAffine(s(Q("pointHex",u)));return d.assertValidity(),d}static fromPrivateKey(u){return f.BASE.multiply(o(u))}_setWindowSize(u){this._WINDOW_SIZE=u,l.delete(this)}assertValidity(){if(this.is0()){if(t.allowInfinityPoint&&!e.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:u,y:d}=this.toAffine();if(!e.isValid(u)||!e.isValid(d))throw new Error("bad point: x or y not FE");const g=e.sqr(d),B=i(u);if(!e.eql(g,B))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:u}=this.toAffine();if(e.isOdd)return!e.isOdd(u);throw new Error("Field doesn't support isOdd")}equals(u){y(u);const{px:d,py:g,pz:B}=this,{px:b,py:H,pz:v}=u,x=e.eql(e.mul(d,v),e.mul(b,B)),A=e.eql(e.mul(g,v),e.mul(H,B));return x&&A}negate(){return new f(this.px,e.neg(this.py),this.pz)}double(){const{a:u,b:d}=t,g=e.mul(d,je),{px:B,py:b,pz:H}=this;let v=e.ZERO,x=e.ZERO,A=e.ZERO,E=e.mul(B,B),k=e.mul(b,b),G=e.mul(H,H),F=e.mul(B,b);return F=e.add(F,F),A=e.mul(B,H),A=e.add(A,A),v=e.mul(u,A),x=e.mul(g,G),x=e.add(v,x),v=e.sub(k,x),x=e.add(k,x),x=e.mul(v,x),v=e.mul(F,v),A=e.mul(g,A),G=e.mul(u,G),F=e.sub(E,G),F=e.mul(u,F),F=e.add(F,A),A=e.add(E,E),E=e.add(A,E),E=e.add(E,G),E=e.mul(E,F),x=e.add(x,E),G=e.mul(b,H),G=e.add(G,G),E=e.mul(G,F),v=e.sub(v,E),A=e.mul(G,k),A=e.add(A,A),A=e.add(A,A),new f(v,x,A)}add(u){y(u);const{px:d,py:g,pz:B}=this,{px:b,py:H,pz:v}=u;let x=e.ZERO,A=e.ZERO,E=e.ZERO;const k=t.a,G=e.mul(t.b,je);let F=e.mul(d,b),z=e.mul(g,H),j=e.mul(B,v),et=e.add(d,g),h=e.add(b,H);et=e.mul(et,h),h=e.add(F,z),et=e.sub(et,h),h=e.add(d,B);let p=e.add(b,v);return h=e.mul(h,p),p=e.add(F,j),h=e.sub(h,p),p=e.add(g,B),x=e.add(H,v),p=e.mul(p,x),x=e.add(z,j),p=e.sub(p,x),E=e.mul(k,h),x=e.mul(G,j),E=e.add(x,E),x=e.sub(z,E),E=e.add(z,E),A=e.mul(x,E),z=e.add(F,F),z=e.add(z,F),j=e.mul(k,j),h=e.mul(G,h),z=e.add(z,j),j=e.sub(F,j),j=e.mul(k,j),h=e.add(h,j),F=e.mul(z,h),A=e.add(A,F),F=e.mul(p,h),x=e.mul(et,x),x=e.sub(x,F),F=e.mul(et,z),E=e.mul(p,E),E=e.add(E,F),new f(x,A,E)}subtract(u){return this.add(u.negate())}is0(){return this.equals(f.ZERO)}wNAF(u){return P.wNAFCached(this,l,u,d=>{const g=e.invertBatch(d.map(B=>B.pz));return d.map((B,b)=>B.toAffine(g[b])).map(f.fromAffine)})}multiplyUnsafe(u){const d=f.ZERO;if(u===ft)return d;if(a(u),u===X)return this;const{endo:g}=t;if(!g)return P.unsafeLadder(this,u);let{k1neg:B,k1:b,k2neg:H,k2:v}=g.splitScalar(u),x=d,A=d,E=this;for(;b>ft||v>ft;)b&X&&(x=x.add(E)),v&X&&(A=A.add(E)),E=E.double(),b>>=X,v>>=X;return B&&(x=x.negate()),H&&(A=A.negate()),A=new f(e.mul(A.px,g.beta),A.py,A.pz),x.add(A)}multiply(u){a(u);let d=u,g,B;const{endo:b}=t;if(b){const{k1neg:H,k1:v,k2neg:x,k2:A}=b.splitScalar(d);let{p:E,f:k}=this.wNAF(v),{p:G,f:F}=this.wNAF(A);E=P.constTimeNegate(H,E),G=P.constTimeNegate(x,G),G=new f(e.mul(G.px,b.beta),G.py,G.pz),g=E.add(G),B=k.add(F)}else{const{p:H,f:v}=this.wNAF(d);g=H,B=v}return f.normalizeZ([g,B])[0]}multiplyAndAddUnsafe(u,d,g){const B=f.BASE,b=(v,x)=>x===ft||x===X||!v.equals(B)?v.multiplyUnsafe(x):v.multiply(x),H=b(this,d).add(b(u,g));return H.is0()?void 0:H}toAffine(u){const{px:d,py:g,pz:B}=this,b=this.is0();u==null&&(u=b?e.ONE:e.inv(B));const H=e.mul(d,u),v=e.mul(g,u),x=e.mul(B,u);if(b)return{x:e.ZERO,y:e.ZERO};if(!e.eql(x,e.ONE))throw new Error("invZ was invalid");return{x:H,y:v}}isTorsionFree(){const{h:u,isTorsionFree:d}=t;if(u===X)return!0;if(d)return d(f,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:u,clearCofactor:d}=t;return u===X?this:d?d(f,this):this.multiplyUnsafe(t.h)}toRawBytes(u=!0){return this.assertValidity(),r(f,this,u)}toHex(u=!0){return Zt(this.toRawBytes(u))}}f.BASE=new f(t.Gx,t.Gy,e.ONE),f.ZERO=new f(e.ZERO,e.ONE,e.ZERO);const w=t.nBitLength,P=ir(f,t.endo?Math.ceil(w/2):w);return{CURVE:t,ProjectivePoint:f,normPrivateKeyToScalar:o,weierstrassEquation:i,isWithinCurveOrder:c}}function fr(n){const t=pn(n);return te(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}function ur(n){const t=fr(n),{Fp:e,n:r}=t,s=e.BYTES+1,i=2*e.BYTES+1;function c(h){return ft<h&&h<e.ORDER}function a(h){return D(h,r)}function o(h){return Ee(h,r)}const{ProjectivePoint:l,normPrivateKeyToScalar:y,weierstrassEquation:f,isWithinCurveOrder:w}=lr({...t,toBytes(h,p,N){const T=p.toAffine(),U=e.toBytes(T.x),V=Jt;return N?V(Uint8Array.from([p.hasEvenY()?2:3]),U):V(Uint8Array.from([4]),U,e.toBytes(T.y))},fromBytes(h){const p=h.length,N=h[0],T=h.subarray(1);if(p===s&&(N===2||N===3)){const U=It(T);if(!c(U))throw new Error("Point is not on curve");const V=f(U);let M=e.sqrt(V);const Y=(M&X)===X;return(N&1)===1!==Y&&(M=e.neg(M)),{x:U,y:M}}else if(p===i&&N===4){const U=e.fromBytes(T.subarray(0,e.BYTES)),V=e.fromBytes(T.subarray(e.BYTES,2*e.BYTES));return{x:U,y:V}}else throw new Error(`Point of length ${p} was invalid. Expected ${s} compressed bytes or ${i} uncompressed bytes`)}}),P=h=>Zt(Dt(h,t.nByteLength));function m(h){const p=r>>X;return h>p}function u(h){return m(h)?a(-h):h}const d=(h,p,N)=>It(h.slice(p,N));class g{constructor(p,N,T){this.r=p,this.s=N,this.recovery=T,this.assertValidity()}static fromCompact(p){const N=t.nByteLength;return p=Q("compactSignature",p,N*2),new g(d(p,0,N),d(p,N,2*N))}static fromDER(p){const{r:N,s:T}=vt.toSig(Q("DER",p));return new g(N,T)}assertValidity(){if(!w(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!w(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(p){return new g(this.r,this.s,p)}recoverPublicKey(p){const{r:N,s:T,recovery:U}=this,V=A(Q("msgHash",p));if(U==null||![0,1,2,3].includes(U))throw new Error("recovery id invalid");const M=U===2||U===3?N+t.n:N;if(M>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const Y=U&1?"03":"02",ut=l.fromHex(Y+P(M)),ht=o(M),Lt=a(-V*ht),Yt=a(T*ht),dt=l.BASE.multiplyAndAddUnsafe(ut,Lt,Yt);if(!dt)throw new Error("point at infinify");return dt.assertValidity(),dt}hasHighS(){return m(this.s)}normalizeS(){return this.hasHighS()?new g(this.r,a(-this.s),this.recovery):this}toDERRawBytes(){return jt(this.toDERHex())}toDERHex(){return vt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return jt(this.toCompactHex())}toCompactHex(){return P(this.r)+P(this.s)}}const B={isValidPrivateKey(h){try{return y(h),!0}catch{return!1}},normPrivateKeyToScalar:y,randomPrivateKey:()=>{const h=yn(t.n);return rr(t.randomBytes(h),t.n)},precompute(h=8,p=l.BASE){return p._setWindowSize(h),p.multiply(BigInt(3)),p}};function b(h,p=!0){return l.fromPrivateKey(h).toRawBytes(p)}function H(h){const p=h instanceof Uint8Array,N=typeof h=="string",T=(p||N)&&h.length;return p?T===s||T===i:N?T===2*s||T===2*i:h instanceof l}function v(h,p,N=!0){if(H(h))throw new Error("first arg must be private key");if(!H(p))throw new Error("second arg must be public key");return l.fromHex(p).multiply(y(h)).toRawBytes(N)}const x=t.bits2int||function(h){const p=It(h),N=h.length*8-t.nBitLength;return N>0?p>>BigInt(N):p},A=t.bits2int_modN||function(h){return a(x(h))},E=Le(t.nBitLength);function k(h){if(typeof h!="bigint")throw new Error("bigint expected");if(!(ft<=h&&h<E))throw new Error(`bigint expected < 2^${t.nBitLength}`);return Dt(h,t.nByteLength)}function G(h,p,N=F){if(["recovered","canonical"].some(Bt=>Bt in N))throw new Error("sign() legacy options not supported");const{hash:T,randomBytes:U}=t;let{lowS:V,prehash:M,extraEntropy:Y}=N;V==null&&(V=!0),h=Q("msgHash",h),M&&(h=Q("prehashed msgHash",T(h)));const ut=A(h),ht=y(p),Lt=[k(ht),k(ut)];if(Y!=null){const Bt=Y===!0?U(e.BYTES):Y;Lt.push(Q("extraEntropy",Bt))}const Yt=Jt(...Lt),dt=ut;function he(Bt){const Ht=x(Bt);if(!w(Ht))return;const Oe=o(Ht),Nt=l.BASE.multiply(Ht).toAffine(),J=a(Nt.x);if(J===ft)return;const Ft=a(Oe*a(dt+J*ht));if(Ft===ft)return;let Ue=(Nt.x===J?0:2)|Number(Nt.y&X),Te=Ft;return V&&m(Ft)&&(Te=u(Ft),Ue^=1),new g(J,Te,Ue)}return{seed:Yt,k2sig:he}}const F={lowS:t.lowS,prehash:!1},z={lowS:t.lowS,prehash:!1};function j(h,p,N=F){const{seed:T,k2sig:U}=G(h,p,N),V=t;return dn(V.hash.outputLen,V.nByteLength,V.hmac)(T,U)}l.BASE._setWindowSize(8);function et(h,p,N,T=z){var Nt;const U=h;if(p=Q("msgHash",p),N=Q("publicKey",N),"strict"in T)throw new Error("options.strict was renamed to lowS");const{lowS:V,prehash:M}=T;let Y,ut;try{if(typeof U=="string"||U instanceof Uint8Array)try{Y=g.fromDER(U)}catch(J){if(!(J instanceof vt.Err))throw J;Y=g.fromCompact(U)}else if(typeof U=="object"&&typeof U.r=="bigint"&&typeof U.s=="bigint"){const{r:J,s:Ft}=U;Y=new g(J,Ft)}else throw new Error("PARSE");ut=l.fromHex(N)}catch(J){if(J.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(V&&Y.hasHighS())return!1;M&&(p=t.hash(p));const{r:ht,s:Lt}=Y,Yt=A(p),dt=o(Lt),he=a(Yt*dt),Bt=a(ht*dt),Ht=(Nt=l.BASE.multiplyAndAddUnsafe(ut,he,Bt))==null?void 0:Nt.toAffine();return Ht?a(Ht.x)===ht:!1}return{CURVE:t,getPublicKey:b,getSharedSecret:v,sign:j,verify:et,ProjectivePoint:l,Signature:g,utils:B}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function hr(n){return{hash:n,hmac:(t,...e)=>sn(n,t,An(...e)),randomBytes:vn}}function dr(n,t){const e=r=>ur({...n,...hr(r)});return Object.freeze({...e(t),create:e})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const mn=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),De=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),gr=BigInt(1),Ae=BigInt(2),Me=(n,t)=>(n+t/Ae)/t;function br(n){const t=mn,e=BigInt(3),r=BigInt(6),s=BigInt(11),i=BigInt(22),c=BigInt(23),a=BigInt(44),o=BigInt(88),l=n*n*n%t,y=l*l*n%t,f=W(y,e,t)*y%t,w=W(f,e,t)*y%t,P=W(w,Ae,t)*l%t,m=W(P,s,t)*P%t,u=W(m,i,t)*m%t,d=W(u,a,t)*u%t,g=W(d,o,t)*d%t,B=W(g,a,t)*u%t,b=W(B,e,t)*y%t,H=W(b,c,t)*m%t,v=W(H,r,t)*l%t,x=W(v,Ae,t);if(!ve.eql(ve.sqr(x),n))throw new Error("Cannot find square root");return x}const ve=nr(mn,void 0,void 0,{sqrt:br}),mt=dr({a:BigInt(0),b:BigInt(7),Fp:ve,n:De,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:n=>{const t=De,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-gr*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=e,c=BigInt("0x100000000000000000000000000000000"),a=Me(i*n,t),o=Me(-r*n,t);let l=D(n-a*e-o*s,t),y=D(-a*r-o*i,t);const f=l>c,w=y>c;if(f&&(l=t-l),w&&(y=t-y),l>c||y>c)throw new Error("splitScalar: Endomorphism failed, k="+n);return{k1neg:f,k1:l,k2neg:w,k2:y}}}},an);BigInt(0);mt.ProjectivePoint;const xn="0x0000000000000000000000000000000000000000";var ct;const At=class At{constructor(t){$(this,ct);L(be(t)===32,"invalid private key","privateKey","[REDACTED]"),I(this,ct,_(t))}get privateKey(){return O(this,ct)}get publicKey(){return At.computePublicKey(O(this,ct))}get compressedPublicKey(){return At.computePublicKey(O(this,ct),!0)}sign(t){L(be(t)===32,"invalid digest length","digest",t);const e=mt.sign(Wt(t),Wt(O(this,ct)),{lowS:!0});return St.from({r:ke(e.r,32),s:ke(e.s,32),v:e.recovery?28:27})}computeSharedSecret(t){const e=At.computePublicKey(t);return _(mt.getSharedSecret(Wt(O(this,ct)),ot(e),!1))}static computePublicKey(t,e){let r=ot(t,"key");if(r.length===32){const i=mt.getPublicKey(r,!!e);return _(i)}if(r.length===64){const i=new Uint8Array(65);i[0]=4,i.set(r,1),r=i}const s=mt.ProjectivePoint.fromHex(r);return _(s.toRawBytes(e))}static recoverPublicKey(t,e){L(be(t)===32,"invalid digest length","digest",t);const r=St.from(e);let s=mt.Signature.fromCompact(Wt(Xt([r.r,r.s])));s=s.addRecoveryBit(r.yParity);const i=s.recoverPublicKey(Wt(t));return L(i!=null,"invalid signautre for digest","signature",e),"0x"+i.toHex(!1)}static addPoints(t,e,r){const s=mt.ProjectivePoint.fromHex(At.computePublicKey(t).substring(2)),i=mt.ProjectivePoint.fromHex(At.computePublicKey(e).substring(2));return"0x"+s.add(i).toHex(!!r)}};ct=new WeakMap;let Qt=At;function me(n,t){return{address:oe(n),storageKeys:t.map((e,r)=>(L(ae(e,32),"invalid slot",`storageKeys[${r}]`,e),e.toLowerCase()))}}function He(n){if(Array.isArray(n))return n.map((e,r)=>Array.isArray(e)?(L(e.length===2,"invalid slot set",`value[${r}]`,e),me(e[0],e[1])):(L(e!=null&&typeof e=="object","invalid address-slot set","value",n),me(e.address,e.storageKeys)));L(n!=null&&typeof n=="object","invalid access list","value",n);const t=Object.keys(n).map(e=>{const r=n[e].reduce((s,i)=>(s[i]=!0,s),{});return me(e,Object.keys(r).sort())});return t.sort((e,r)=>e.address.localeCompare(r.address)),t}function yr(n){let t;return typeof n=="string"?t=Qt.computePublicKey(n,!1):t=n.publicKey,oe(we("0x"+t.substring(4)).substring(26))}function pr(n,t){return yr(Qt.recoverPublicKey(n,t))}const K=BigInt(0),mr=BigInt(2),xr=BigInt(27),wr=BigInt(28),Br=BigInt(35),Er=BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),xe=4096*32;function Ye(n,t){let e=n.toString(16);for(;e.length<2;)e="0"+e;return e+=Mt(t).substring(4),"0x"+e}function ue(n){return n==="0x"?null:oe(n)}function Ne(n,t){try{return He(n)}catch(e){L(!1,e.message,t,n)}}function ee(n,t){return n==="0x"?0:tn(n,t)}function R(n,t){if(n==="0x")return K;const e=st(n,t);return L(e<=Er,"value exceeds uint size",t,e),e}function C(n,t){const e=st(n,"value"),r=tt(e);return L(r.length<=32,"value too large",`tx.${t}`,e),r}function Fe(n){return He(n).map(t=>[t.address,t.storageKeys])}function Ar(n,t){L(Array.isArray(n),`invalid ${t}`,"value",n);for(let e=0;e<n.length;e++)L(ae(n[e],32),"invalid ${ param } hash",`value[${e}]`,n[e]);return n}function vr(n){const t=ce(n);L(Array.isArray(t)&&(t.length===9||t.length===6),"invalid field count for legacy transaction","data",n);const e={type:0,nonce:ee(t[0],"nonce"),gasPrice:R(t[1],"gasPrice"),gasLimit:R(t[2],"gasLimit"),to:ue(t[3]),value:R(t[4],"value"),data:_(t[5]),chainId:K};if(t.length===6)return e;const r=R(t[6],"v"),s=R(t[7],"r"),i=R(t[8],"s");if(s===K&&i===K)e.chainId=r;else{let c=(r-Br)/mr;c<K&&(c=K),e.chainId=c,L(c!==K||r===xr||r===wr,"non-canonical legacy v","v",t[6]),e.signature=St.from({r:ie(t[7],32),s:ie(t[8],32),v:r})}return e}function Pr(n,t){const e=[C(n.nonce,"nonce"),C(n.gasPrice||0,"gasPrice"),C(n.gasLimit,"gasLimit"),n.to||"0x",C(n.value,"value"),n.data];let r=K;if(n.chainId!=K)r=st(n.chainId,"tx.chainId"),L(!t||t.networkV==null||t.legacyChainId===r,"tx.chainId/sig.v mismatch","sig",t);else if(n.signature){const i=n.signature.legacyChainId;i!=null&&(r=i)}if(!t)return r!==K&&(e.push(tt(r)),e.push("0x"),e.push("0x")),Kt(e);let s=BigInt(27+t.yParity);return r!==K?s=St.getChainIdV(r,t.v):BigInt(t.v)!==s&&L(!1,"tx.chainId/sig.v mismatch","sig",t),e.push(tt(s)),e.push(tt(t.r)),e.push(tt(t.s)),Kt(e)}function Ge(n,t){let e;try{if(e=ee(t[0],"yParity"),e!==0&&e!==1)throw new Error("bad yParity")}catch{L(!1,"invalid yParity","yParity",t[0])}const r=ie(t[1],32),s=ie(t[2],32),i=St.from({r,s,yParity:e});n.signature=i}function Ir(n){const t=ce(ot(n).slice(1));L(Array.isArray(t)&&(t.length===9||t.length===12),"invalid field count for transaction type: 2","data",_(n));const e={type:2,chainId:R(t[0],"chainId"),nonce:ee(t[1],"nonce"),maxPriorityFeePerGas:R(t[2],"maxPriorityFeePerGas"),maxFeePerGas:R(t[3],"maxFeePerGas"),gasPrice:null,gasLimit:R(t[4],"gasLimit"),to:ue(t[5]),value:R(t[6],"value"),data:_(t[7]),accessList:Ne(t[8],"accessList")};return t.length===9||Ge(e,t.slice(9)),e}function Sr(n,t){const e=[C(n.chainId,"chainId"),C(n.nonce,"nonce"),C(n.maxPriorityFeePerGas||0,"maxPriorityFeePerGas"),C(n.maxFeePerGas||0,"maxFeePerGas"),C(n.gasLimit,"gasLimit"),n.to||"0x",C(n.value,"value"),n.data,Fe(n.accessList||[])];return t&&(e.push(C(t.yParity,"yParity")),e.push(tt(t.r)),e.push(tt(t.s))),Xt(["0x02",Kt(e)])}function Lr(n){const t=ce(ot(n).slice(1));L(Array.isArray(t)&&(t.length===8||t.length===11),"invalid field count for transaction type: 1","data",_(n));const e={type:1,chainId:R(t[0],"chainId"),nonce:ee(t[1],"nonce"),gasPrice:R(t[2],"gasPrice"),gasLimit:R(t[3],"gasLimit"),to:ue(t[4]),value:R(t[5],"value"),data:_(t[6]),accessList:Ne(t[7],"accessList")};return t.length===8||Ge(e,t.slice(8)),e}function Hr(n,t){const e=[C(n.chainId,"chainId"),C(n.nonce,"nonce"),C(n.gasPrice||0,"gasPrice"),C(n.gasLimit,"gasLimit"),n.to||"0x",C(n.value,"value"),n.data,Fe(n.accessList||[])];return t&&(e.push(C(t.yParity,"recoveryParam")),e.push(tt(t.r)),e.push(tt(t.s))),Xt(["0x01",Kt(e)])}function Nr(n){let t=ce(ot(n).slice(1)),e="3",r=null;if(t.length===4&&Array.isArray(t[0])){e="3 (network format)";const i=t[1],c=t[2],a=t[3];L(Array.isArray(i),"invalid network format: blobs not an array","fields[1]",i),L(Array.isArray(c),"invalid network format: commitments not an array","fields[2]",c),L(Array.isArray(a),"invalid network format: proofs not an array","fields[3]",a),L(i.length===c.length,"invalid network format: blobs/commitments length mismatch","fields",t),L(i.length===a.length,"invalid network format: blobs/proofs length mismatch","fields",t),r=[];for(let o=0;o<t[1].length;o++)r.push({data:i[o],commitment:c[o],proof:a[o]});t=t[0]}L(Array.isArray(t)&&(t.length===11||t.length===14),`invalid field count for transaction type: ${e}`,"data",_(n));const s={type:3,chainId:R(t[0],"chainId"),nonce:ee(t[1],"nonce"),maxPriorityFeePerGas:R(t[2],"maxPriorityFeePerGas"),maxFeePerGas:R(t[3],"maxFeePerGas"),gasPrice:null,gasLimit:R(t[4],"gasLimit"),to:ue(t[5]),value:R(t[6],"value"),data:_(t[7]),accessList:Ne(t[8],"accessList"),maxFeePerBlobGas:R(t[9],"maxFeePerBlobGas"),blobVersionedHashes:t[10]};r&&(s.blobs=r),L(s.to!=null,`invalid address for transaction type: ${e}`,"data",n),L(Array.isArray(s.blobVersionedHashes),"invalid blobVersionedHashes: must be an array","data",n);for(let i=0;i<s.blobVersionedHashes.length;i++)L(ae(s.blobVersionedHashes[i],32),`invalid blobVersionedHash at index ${i}: must be length 32`,"data",n);return t.length===11||Ge(s,t.slice(11)),s}function Fr(n,t,e){const r=[C(n.chainId,"chainId"),C(n.nonce,"nonce"),C(n.maxPriorityFeePerGas||0,"maxPriorityFeePerGas"),C(n.maxFeePerGas||0,"maxFeePerGas"),C(n.gasLimit,"gasLimit"),n.to||xn,C(n.value,"value"),n.data,Fe(n.accessList||[]),C(n.maxFeePerBlobGas||0,"maxFeePerBlobGas"),Ar(n.blobVersionedHashes||[],"blobVersionedHashes")];return t&&(r.push(C(t.yParity,"yParity")),r.push(tt(t.r)),r.push(tt(t.s)),e)?Xt(["0x03",Kt([r,e.map(s=>s.data),e.map(s=>s.commitment),e.map(s=>s.proof)])]):Xt(["0x03",Kt(r)])}var it,Gt,Ot,Ut,Tt,Ct,kt,_t,qt,Rt,$t,zt,Pt,xt,lt,wt,Vt,re;const at=class at{constructor(){$(this,Vt);$(this,it);$(this,Gt);$(this,Ot);$(this,Ut);$(this,Tt);$(this,Ct);$(this,kt);$(this,_t);$(this,qt);$(this,Rt);$(this,$t);$(this,zt);$(this,Pt);$(this,xt);$(this,lt);$(this,wt);I(this,it,null),I(this,Gt,null),I(this,Ut,0),I(this,Tt,K),I(this,Ct,null),I(this,kt,null),I(this,_t,null),I(this,Ot,"0x"),I(this,qt,K),I(this,Rt,K),I(this,$t,null),I(this,zt,null),I(this,Pt,null),I(this,xt,null),I(this,wt,null),I(this,lt,null)}get type(){return O(this,it)}set type(t){switch(t){case null:I(this,it,null);break;case 0:case"legacy":I(this,it,0);break;case 1:case"berlin":case"eip-2930":I(this,it,1);break;case 2:case"london":case"eip-1559":I(this,it,2);break;case 3:case"cancun":case"eip-4844":I(this,it,3);break;default:L(!1,"unsupported transaction type","type",t)}}get typeName(){switch(this.type){case 0:return"legacy";case 1:return"eip-2930";case 2:return"eip-1559";case 3:return"eip-4844"}return null}get to(){const t=O(this,Gt);return t==null&&this.type===3?xn:t}set to(t){I(this,Gt,t==null?null:oe(t))}get nonce(){return O(this,Ut)}set nonce(t){I(this,Ut,tn(t,"value"))}get gasLimit(){return O(this,Tt)}set gasLimit(t){I(this,Tt,st(t))}get gasPrice(){const t=O(this,Ct);return t==null&&(this.type===0||this.type===1)?K:t}set gasPrice(t){I(this,Ct,t==null?null:st(t,"gasPrice"))}get maxPriorityFeePerGas(){const t=O(this,kt);return t??(this.type===2||this.type===3?K:null)}set maxPriorityFeePerGas(t){I(this,kt,t==null?null:st(t,"maxPriorityFeePerGas"))}get maxFeePerGas(){const t=O(this,_t);return t??(this.type===2||this.type===3?K:null)}set maxFeePerGas(t){I(this,_t,t==null?null:st(t,"maxFeePerGas"))}get data(){return O(this,Ot)}set data(t){I(this,Ot,_(t))}get value(){return O(this,qt)}set value(t){I(this,qt,st(t,"value"))}get chainId(){return O(this,Rt)}set chainId(t){I(this,Rt,st(t))}get signature(){return O(this,$t)||null}set signature(t){I(this,$t,t==null?null:St.from(t))}get accessList(){const t=O(this,zt)||null;return t??(this.type===1||this.type===2||this.type===3?[]:null)}set accessList(t){I(this,zt,t==null?null:He(t))}get maxFeePerBlobGas(){const t=O(this,Pt);return t==null&&this.type===3?K:t}set maxFeePerBlobGas(t){I(this,Pt,t==null?null:st(t,"maxFeePerBlobGas"))}get blobVersionedHashes(){let t=O(this,xt);return t==null&&this.type===3?[]:t}set blobVersionedHashes(t){if(t!=null){L(Array.isArray(t),"blobVersionedHashes must be an Array","value",t),t=t.slice();for(let e=0;e<t.length;e++)L(ae(t[e],32),"invalid blobVersionedHash",`value[${e}]`,t[e])}I(this,xt,t)}get blobs(){return O(this,wt)==null?null:O(this,wt).map(t=>Object.assign({},t))}set blobs(t){if(t==null){I(this,wt,null);return}const e=[],r=[];for(let s=0;s<t.length;s++){const i=t[s];if(Pn(i)){rt(O(this,lt),"adding a raw blob requires a KZG library","UNSUPPORTED_OPERATION",{operation:"set blobs()"});let c=ot(i);if(L(c.length<=xe,"blob is too large",`blobs[${s}]`,i),c.length!==xe){const l=new Uint8Array(xe);l.set(c),c=l}const a=O(this,lt).blobToKzgCommitment(c),o=_(O(this,lt).computeBlobKzgProof(c,a));e.push({data:_(c),commitment:_(a),proof:o}),r.push(Ye(1,a))}else{const c=_(i.commitment);e.push({data:_(i.data),commitment:c,proof:_(i.proof)}),r.push(Ye(1,c))}}I(this,wt,e),I(this,xt,r)}get kzg(){return O(this,lt)}set kzg(t){I(this,lt,t)}get hash(){return this.signature==null?null:we(ne(this,Vt,re).call(this,!0,!1))}get unsignedHash(){return we(this.unsignedSerialized)}get from(){return this.signature==null?null:pr(this.unsignedHash,this.signature)}get fromPublicKey(){return this.signature==null?null:Qt.recoverPublicKey(this.unsignedHash,this.signature)}isSigned(){return this.signature!=null}get serialized(){return ne(this,Vt,re).call(this,!0,!0)}get unsignedSerialized(){return ne(this,Vt,re).call(this,!1,!1)}inferType(){const t=this.inferTypes();return t.indexOf(2)>=0?2:t.pop()}inferTypes(){const t=this.gasPrice!=null,e=this.maxFeePerGas!=null||this.maxPriorityFeePerGas!=null,r=this.accessList!=null,s=O(this,Pt)!=null||O(this,xt);this.maxFeePerGas!=null&&this.maxPriorityFeePerGas!=null&&rt(this.maxFeePerGas>=this.maxPriorityFeePerGas,"priorityFee cannot be more than maxFee","BAD_DATA",{value:this}),rt(!e||this.type!==0&&this.type!==1,"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas","BAD_DATA",{value:this}),rt(this.type!==0||!r,"legacy transaction cannot have accessList","BAD_DATA",{value:this});const i=[];return this.type!=null?i.push(this.type):e?i.push(2):t?(i.push(1),r||i.push(0)):r?(i.push(1),i.push(2)):(s&&this.to||(i.push(0),i.push(1),i.push(2)),i.push(3)),i.sort(),i}isLegacy(){return this.type===0}isBerlin(){return this.type===1}isLondon(){return this.type===2}isCancun(){return this.type===3}clone(){return at.from(this)}toJSON(){const t=e=>e==null?null:e.toString();return{type:this.type,to:this.to,data:this.data,nonce:this.nonce,gasLimit:t(this.gasLimit),gasPrice:t(this.gasPrice),maxPriorityFeePerGas:t(this.maxPriorityFeePerGas),maxFeePerGas:t(this.maxFeePerGas),value:t(this.value),chainId:t(this.chainId),sig:this.signature?this.signature.toJSON():null,accessList:this.accessList}}static from(t){if(t==null)return new at;if(typeof t=="string"){const r=ot(t);if(r[0]>=127)return at.from(vr(r));switch(r[0]){case 1:return at.from(Lr(r));case 2:return at.from(Ir(r));case 3:return at.from(Nr(r))}rt(!1,"unsupported transaction type","UNSUPPORTED_OPERATION",{operation:"from"})}const e=new at;return t.type!=null&&(e.type=t.type),t.to!=null&&(e.to=t.to),t.nonce!=null&&(e.nonce=t.nonce),t.gasLimit!=null&&(e.gasLimit=t.gasLimit),t.gasPrice!=null&&(e.gasPrice=t.gasPrice),t.maxPriorityFeePerGas!=null&&(e.maxPriorityFeePerGas=t.maxPriorityFeePerGas),t.maxFeePerGas!=null&&(e.maxFeePerGas=t.maxFeePerGas),t.maxFeePerBlobGas!=null&&(e.maxFeePerBlobGas=t.maxFeePerBlobGas),t.data!=null&&(e.data=t.data),t.value!=null&&(e.value=t.value),t.chainId!=null&&(e.chainId=t.chainId),t.signature!=null&&(e.signature=St.from(t.signature)),t.accessList!=null&&(e.accessList=t.accessList),t.blobVersionedHashes!=null&&(e.blobVersionedHashes=t.blobVersionedHashes),t.kzg!=null&&(e.kzg=t.kzg),t.blobs!=null&&(e.blobs=t.blobs),t.hash!=null&&(L(e.isSigned(),"unsigned transaction cannot define '.hash'","tx",t),L(e.hash===t.hash,"hash mismatch","tx",t)),t.from!=null&&(L(e.isSigned(),"unsigned transaction cannot define '.from'","tx",t),L(e.from.toLowerCase()===(t.from||"").toLowerCase(),"from mismatch","tx",t)),e}};it=new WeakMap,Gt=new WeakMap,Ot=new WeakMap,Ut=new WeakMap,Tt=new WeakMap,Ct=new WeakMap,kt=new WeakMap,_t=new WeakMap,qt=new WeakMap,Rt=new WeakMap,$t=new WeakMap,zt=new WeakMap,Pt=new WeakMap,xt=new WeakMap,lt=new WeakMap,wt=new WeakMap,Vt=new WeakSet,re=function(t,e){rt(!t||this.signature!=null,"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized","UNSUPPORTED_OPERATION",{operation:".serialized"});const r=t?this.signature:null;switch(this.inferType()){case 0:return Pr(this,r);case 1:return Hr(this,r);case 2:return Sr(this,r);case 3:return Fr(this,r,e?this.blobs:null)}rt(!1,"unsupported transaction type","UNSUPPORTED_OPERATION",{operation:".serialized"})};let We=at;export{kr as MessagePrefix,St as Signature,Qt as SigningKey,We as Transaction,_r as TypedDataEncoder,xn as ZeroAddress,qr as ZeroHash,He as accessListify,rt as assert,L as assertArgument,Rr as assertPrivate,yr as computeAddress,Xt as concat,be as dataLength,ce as decodeRlp,$r as defineProperties,Kt as encodeRlp,oe as getAddress,st as getBigInt,ot as getBytes,Wt as getBytesCopy,tn as getNumber,zr as getUint,Vr as hashMessage,_ as hexlify,Kr as id,Pn as isBytesLike,ae as isHexString,we as keccak256,Zr as makeError,jr as mask,pr as recoverAddress,Mt as sha256,tt as toBeArray,ke as toBeHex,Dr as toQuantity,Mr as toTwos,Yr as toUtf8Bytes,Wr as version,ie as zeroPadValue};
